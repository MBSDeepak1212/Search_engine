 The algorithm takes input a bit-string SSS of length NNN and returns a ciphertext of the same length. The pseudo-code for the algorithm is -Encryption (S, N ){    cipher = S    for i \xe2\x86\x92 1 to N :         j = ( i == N ) ? 1 : i+1        if ( S[i] == '1' and S[j] == '0' ) :            cipher[i] = '0'            cipher[j] = '1'    return cipher        }Note:SSS contains only '1's and '0's.The given algorithm works on 1-based indexing.For example, if the original bit-string SSS was 010101, the encryption function returns 101010.Unfortunately, the above algorithm is not perfect, as more than one SSS can have the same ciphertext. For a given ciphertext, Naveen wants to find out how many original bit-string SSS are possible.    For example, for the ciphertext '01001', there are two possible original strings - '10001' and '10010'.Naveen is busy preparing for the end-sem exams, can you help him by implementing a function that calculates the total possible original strings for a given ciphertext?.The answer can be very large, so print answeransweranswer% (109+7)(109+7)(10 ^9 + 7).